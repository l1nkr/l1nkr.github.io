<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"l1nkr.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="学习操作系统时的一些笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统知识点">
<meta property="og:url" content="https://l1nkr.github.io/2021/07/12/osnote-md/index.html">
<meta property="og:site_name" content="变秃之路">
<meta property="og:description" content="学习操作系统时的一些笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_14-25-46.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_16-42-27.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_16-55-15.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_17-18-02.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_17-36-12.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_18-02-05.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_18-03-27.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_18-21-13.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_18-31-48.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_18-35-55.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_18-43-06.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_18-53-22.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-04_13-16-58.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-04_13-19-24.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-04_13-28-02.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-04_13-28-57.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-04_13-30-51.jpg">
<meta property="og:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-04_13-31-58.jpg">
<meta property="article:published_time" content="2021-07-12T02:38:16.000Z">
<meta property="article:modified_time" content="2021-12-06T11:11:56.385Z">
<meta property="article:author" content="l1nkr">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://l1nkr.github.io/2021/07/12/osnote-md/Xnip2021-06-03_14-25-46.jpg">

<link rel="canonical" href="https://l1nkr.github.io/2021/07/12/osnote-md/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>操作系统知识点 | 变秃之路</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="变秃之路" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">变秃之路</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">变秃之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://l1nkr.github.io/2021/07/12/osnote-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ye.jpg">
      <meta itemprop="name" content="l1nkr">
      <meta itemprop="description" content="Work it harder. Make it better">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="变秃之路">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统知识点
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-12 10:38:16" itemprop="dateCreated datePublished" datetime="2021-07-12T10:38:16+08:00">2021-07-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-06 19:11:56" itemprop="dateModified" datetime="2021-12-06T19:11:56+08:00">2021-12-06</time>
              </span>

          
            <div class="post-description">学习操作系统时的一些笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第一章-导论"><a href="#第一章-导论" class="headerlink" title="第一章 导论"></a>第一章 导论</h2><p>现代通用计算机系统由一个或多个CPU和若干设备控制器通过共同的总线相连而成。</p>
<p>打开电源或重启——运行初始化程序（引导程序）——定位操作系统并将其装入内存——执行第一个进程</p>
<p>引导程序：通常位于ROM或者EEPROM，称为计算机硬件中的固件。用来初始化系统的所有部分（CPU寄存器，设备控制器和内存）。<br>中断：硬件可随时通过系统总线向CPU发出信号，出发中断。软件通过系统调用（或者其他特别操作）触发中断。<br>发生中断——调用一个通用子程序检查中断信息——使用中断处理指针表（中断向量）——间接调用中断处理子程序</p>
<p>现在的操作系统都是以中断为驱动的。</p>
<p>操作系统三种基本类型</p>
<ul>
<li>Batch systems（批处理系统）</li>
<li>Time-sharingsystems（分时系统）</li>
<li>Real timesystems（实时系统）</li>
</ul>
<h2 id="第二章-操作系统结构"><a href="#第二章-操作系统结构" class="headerlink" title="第二章 操作系统结构"></a>第二章 操作系统结构</h2><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>向操作系统传递参数的三种方法</p>
<ol>
<li>通过寄存器来传递参数。</li>
<li>若参数数量比寄存器多，参数通常存在内存的块和表中，并将块的地址通过寄存器来传递。</li>
<li>参数也可以通过程序放在或压入堆栈中，并通过操作系统弹出。<h4 id="系统调用类型"><a href="#系统调用类型" class="headerlink" title="系统调用类型"></a>系统调用类型</h4>进程控制、文件管理、设备管理、信息维护和通信</li>
</ol>
<h4 id="系统程序分类"><a href="#系统程序分类" class="headerlink" title="系统程序分类"></a>系统程序分类</h4><p>文件管理、状态信息、文件修改、程序语言支持、程序装入和执行、通信。</p>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><p>简单结构、分层方法、微内核、模块、虚拟机</p>
<h4 id="分层方法"><a href="#分层方法" class="headerlink" title="分层方法"></a>分层方法</h4><p>定义：操作系统分成若干层（级）。最底层（层0）为硬件，最高层（层N）为用户接口。每层只考虑较低层的功能和服务。</p>
<p>优点：</p>
<ul>
<li>每层都是利用较低层所提供的功能实现的，并为叫高层隐藏了一定的数据结构、操作和硬件的存在<br>缺点：</li>
<li>分层法的主要困难涉及对层的详细定义<br>与其它方法相比效率较差</li>
</ul>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>微内核方法将所有非基本部分从内核中移走，并将它们实现为系统或用户程序，这样得到了更小的内核。<br>微内核的主要功能是使客户程序和运行在用户空间的各种服务之间进行通信。</p>
<p>优点：</p>
<ul>
<li>便于扩充操作系统</li>
<li>很容易从一种硬件平台设计移植到另一种硬件平台设计</li>
<li>更安全、可靠</li>
</ul>
<p>缺点：</p>
<ul>
<li>由于系统功能总开销的增加而导致系统性能的下降。</li>
</ul>
<h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>大多数现代操作系统实现内核模块：</p>
<p>采用面向对象的方法</p>
<p>每个核心组件是分开的</p>
<p>每部分与已知接口的其他部分通信</p>
<p>每部分根据需要加载到内核</p>
<p>总之，类似于层，但更灵活。</p>
<h2 id="第三章-进程"><a href="#第三章-进程" class="headerlink" title="第三章 进程"></a>第三章 进程</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>进程包含了程序代码和当前活动（其中当前活动通过程序计数器和处理器寄存器的内容表示）两个部分，进程是执行中的程序。具体有：</p>
<ul>
<li>文本段（代码段）</li>
<li>数据段（全局变量）</li>
<li>栈（stack）（包含临时数据、函数参数、返回地址、局部变量）</li>
<li>堆（heap）（进程运行期间动态分配的内存）</li>
<li>程序计数器<br>注意： 程序是被动实体，进程是活动实体（其中当前活动通过程序计数器和处理器寄存器的内容表示）</li>
</ul>
<p>两个进程可以与同一程序联系，虽然文本段相同。但是数据段、堆栈段不同</p>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><ul>
<li>New（新的）</li>
<li>Running（运行）</li>
<li>Waiting（等待）</li>
<li>Ready（就绪）</li>
<li>Terminated（终止）</li>
</ul>
<h4 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h4><p>每一个进程都需要分配一定的信息，这些信息的仓库就叫做PCB，PCB有以下功能：</p>
<p>系统利用PCB 控制 和 管理 进程<br>PCB是进程存在的唯一标志<br>操作系统通过PCB感知进程的存在</p>
<ul>
<li>程序计数器：表示进程要执行的下个指令的地址</li>
<li>CPU寄存器：与程序计数器一起，在出现中断时状态信息需要保存，使进程能够正确执行</li>
<li>CPU调度信息：包括优先级、调度队列的指针等（见第五章）</li>
<li>内存管理信息：（见第八章）</li>
<li>记账信息：包括CPU时间、实际使用时间、时间界限、记账数据、作业和进程数量等</li>
<li>IO状态信息：分配给进程的IO设备列表，打开的文件列表等</li>
</ul>
<h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="调度队列"><a href="#调度队列" class="headerlink" title="调度队列"></a>调度队列</h4><ul>
<li>作业（Job）队列：包含了系统中所有的进程</li>
<li>就绪（Ready）队列：包含了系统中，驻留在内存中就绪的，准备运行的进程<br>  该队列通常用链表实现，头结点指向第一个和最后一个PCB块的指针，每个PCB块包括指向下一个PCB的指针域</li>
<li>设备（Device）队列：包含了等待特定IO设备的进程列表<br>  进程可能会有IO请求，请求时可能IO设备在处理其他请求，所以该进程需要等待。</li>
</ul>
<h4 id="调度程序"><a href="#调度程序" class="headerlink" title="调度程序"></a>调度程序</h4><p>长期调度程序（long-term schedule） / 作业调度程序（job schedule）：负责从缓冲池中选择进程，装入内存以便执行<br>短期调度程序（short-term schedule） / CPU调度程序（CPU schedule）：从执行的进程中选择进程，并为之分配CPU</p>
<h3 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>进程是需要一定的资源的（CPU时间，内存，文件，IO设备），在一个进程创建子进程的时候，在父进程和子进程之间需要分配 / 共享资源，有以下几种情况：</p>
<ul>
<li>从操作系统哪里获取资源</li>
<li>从父进程中获取资源（限制子进程只能从父进程中获取资源能防止创建过多的进程导致系统超载）</li>
</ul>
<p>在进程创建时，该进程会得到：</p>
<ul>
<li>各种物理和逻辑资源</li>
<li>父进程传递来的初始化数据或输入</li>
<li>通常子进程会返回给父进程自身的标识符（系统中唯一标识进程身份的id）</li>
</ul>
<h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>进程终止的时间：</p>
<ul>
<li>执行完最后语句，并使用系统调用exit()请求操作系统删除自身。</li>
<li>一个进程通过适当的系统调用终止另一个进程（通常这个进程需要是被终止进程的父进程，并且这需要知道被终止进程的标识符）</li>
</ul>
<p>父进程终止子进程的原因一般有：</p>
<ul>
<li>子进程使用的资源超过了父进程分配的资源</li>
<li>分配给子进程的任务不再需要</li>
<li>父进程退出，在这种情况下，操作系统不允许子进程继续.有些系统如果一个进程终止，那么它所有的子进程都终止。这叫做级联终止。通常有操作系统进行</li>
</ul>
<p>进程终止后：</p>
<ul>
<li>进程会返回状态值（通常为整数）到父进程</li>
<li>所有进程资源会被操作系统释放</li>
</ul>
<p>如果父进程终止，那么其所有子进程会以init进程作为父进程。因此，子进程仍然有一个父进程来收集状态和执行统计</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>并发执行的进程有两类，<strong>一类是 独立进程，不能影响其他进程并且不被其他进程影响。</strong><br><strong>另一类是协作进程，能影响其他进程或被其他进程影响</strong></p>
<p>允许进程协作的优点：</p>
<ul>
<li>信息共享</li>
<li>提高运算速度</li>
<li>模块化</li>
<li>方便</li>
</ul>
<p>因此协作进程需要一种进程间通信机制（IPC）来允许进程相互交换数据与信息。有<strong>共享内存和信息传递</strong>两种类型</p>
<p>共享内存系统</p>
<ul>
<li>比消息传递更快</li>
<li>只在建立共享内存区时需要系统调用</li>
</ul>
<p>消息传递：</p>
<ul>
<li>不需要避免冲突</li>
<li>通常需要系统调用实现，需要更多的内核介入的时间消耗</li>
</ul>
<h2 id="第四章-线程"><a href="#第四章-线程" class="headerlink" title="第四章 线程"></a>第四章 线程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>线程是CPU使用的基本单元，由<strong>线程ID，程序计数器，寄存器集合和栈</strong>组成。<br>它与属于同一进程的其他线程共享<strong>代码段，数据段和其他操作系统资源</strong></p>
<h4 id="多线程优点"><a href="#多线程优点" class="headerlink" title="多线程优点"></a>多线程优点</h4><ul>
<li>响应度高：一个多线程的程序即使部分阻塞，其他部分仍能运行，从而增加了对用户的响应程度。</li>
<li>资源共享</li>
<li>经济：创建和切换线程比创建进程更节省资源和时间</li>
<li>多处理器体系结构的利用</li>
</ul>
<h4 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h4><p>多对一<br>一对一<br>多对多</p>
<h3 id="多线程问题"><a href="#多线程问题" class="headerlink" title="多线程问题"></a>多线程问题</h3><h4 id="fork-exec"><a href="#fork-exec" class="headerlink" title="fork() exec()"></a>fork() exec()</h4><p>在多线程程序中，系统调用fork()和exec()的语义有所改变。</p>
<p>如果程序中一个进程调用fork()，那么新进程会复制所有线程，还是新进程只有单个线程？<br><strong>有的UNIX系统有两种形式的fork()，一种复制所有线程，另一种只复制调用了系统调用fork()的线程。</strong></p>
<p>Exec()工作方式：<strong>如果一个线程调用系统调用exec()，那么exec()参数所指定的程序会替换整个进程，包括所有线程。</strong></p>
<p>如果调用fork()之后立即调用exec()，那么没有必要复制所有线程，因为exec()参数所指定的程序会替换整个进程。在这种情况下，只复制调用线程比较适当。<br>不过，如果在fork()之后另一进程并不调用exec(),那么另一进程就应复制所有进程。</p>
<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><p><strong>线程取消（Thread cancellation）是在线程完成之前来终止线程。</strong><br>被取消的线程通常被称为目标线程（target thread）。<br>取消一个目标线程可能发生在两个不同的场景:</p>
<ul>
<li>异步取消（Asynchronous cancellation）：一个线程立即终止目标线程。</li>
<li>延迟取消（Deferred cancellation）：目标线程定期检查自己是否应该终止，这允许目标线程有机会以有序方式来终止自己。</li>
</ul>
<p>当资源被分配给一个被取消的线程，或者要取消的线程正在更新与其他线程共享的数据时，那么线程取消就会遇到麻烦。尤其对于异步取消非常麻烦。</p>
<p>通常，操作系统会从被取消的线程中回收系统资源，但不会回收所有资源。<br>因此，异步取消线程可能无法释放必要的系统资源。</p>
<p>对于延迟取消，则相反，一个线程指示目标线程被取消，但是只有在目标线程检查了一个标志以确定是否应该取消它之后才会发生取消。<br>线程可以在一个可以被安全取消的点上执行此检查。<br>在Pthreads中，线程取消使用pthread_cancel()函数。目标线程的标识符作为参数传递给该函数。<br>调用pthread_cancel()只表示要取消目标线程的请求。然而，真实的取消取决于目标线程是如何设置来处理这个请求的<br>Pthreads允许<strong>关闭（disabled）或者开启（enabled）线程取消</strong>。</p>
<p>显然，如果关闭（disabled）了线程取消，则不能取消线程。但是，取消请求仍在等待中，因此线程可以稍后启用（enabled）线程取消并响应请求。<br>默认的线程取消类型是延迟取消（deferred cancellation）。在延迟取消模式下，只有当线程到达了取消点（cancellation point）,线程取消才会发生。<br>建立取消点的一种技术是调用pthread_testcancel()函数。如果发现取消请求正在等待，将调用一个名为清除处理程序（cleanup handler）的函数。该函数允许在线程终止之前，释放掉线程可能获得的任何资源。</p>
<h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><p>从CUP资源占用角度考虑并发与并行：</p>
<p>并发：单个CPU的操作系统在进行多线程操作时，将CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段内只运行一个线程，其他线程处于挂起状态。</p>
<p>并行：对于多CPU系统进行多线程操作，一个CPU在执行一个线程时，另一个CPU执行另一个线程。两个线程互不抢CPU资源，可以同时进行。<br><img src="/2021/07/12/osnote-md/Xnip2021-06-03_14-25-46.jpg"></p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p><strong>互斥共享方式</strong></p>
<p><strong>同时访问方式</strong><br>“同时”通常是宏观上的，微观上可能是进行交替对该资源进行访问</p>
<h4 id="硬中断-软中断"><a href="#硬中断-软中断" class="headerlink" title="硬中断 软中断"></a>硬中断 软中断</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/aresxin/articles/9152136.html">https://www.cnblogs.com/aresxin/articles/9152136.html</a><br>举一个简单的例子<br>程序（io请求）&lt;—–&gt; 内核 (io请求) &lt;—–&gt; 硬件设备<br>             软中断                硬中断</p>
<h4 id="孤儿进程-僵尸进程"><a href="#孤儿进程-僵尸进程" class="headerlink" title="孤儿进程 僵尸进程"></a>孤儿进程 僵尸进程</h4><p>僵尸进程：父进程仍运行 &amp;&amp; 子进程已结束 &amp;&amp; 父进程未对子进程调用wait()<br>孤儿进程：孤儿进程可能是由于级联终止造成的吧，比如说父进程突然终止了，那么进程树下的子进程也应该被终止，在子进程未被终止前它是一个孤儿进程，孤儿进程是一个很短暂的状态，因为他一旦成为了孤儿进程就会有人来收养他，比如说init进程</p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>单线程程序的信号处理比较直接，信号总是发送给进程。<br>当多线程时，信号会</p>
<ul>
<li>发送信号到信号所应用的线程</li>
<li>发送信号到进程内的每个线程</li>
<li>发送信号到进程内的某些固定线程</li>
<li>规定一个特定线程以接收进程的所有信号。</li>
</ul>
<p>发送信号的方法依赖于信号的类型。</p>
<h4 id="TLS-线程局部存储-thread-local-storage"><a href="#TLS-线程局部存储-thread-local-storage" class="headerlink" title="TLS 线程局部存储 thread local storage"></a>TLS 线程局部存储 thread local storage</h4><p>同属一个进程的线程共享进程数据<br>在某些情况下每个线程可能需要一定数据的自己的副本，这种数据称为线程特定数据。可以让每个线程与其唯一的标识符相关联</p>
<h2 id="第五章-CPU调度"><a href="#第五章-CPU调度" class="headerlink" title="第五章 CPU调度"></a>第五章 CPU调度</h2><h4 id="抢占调度"><a href="#抢占调度" class="headerlink" title="抢占调度"></a>抢占调度</h4><p>CPU调度决策可在如下4种情况环境下发生：</p>
<ul>
<li>当一个进程从运行切换到等待状态（如：I/O请求，或者调用wait等待一个子进程的终止）</li>
<li>当一个进程从运行状态切换到就绪状态（如：出现中断）</li>
<li>当一个进程从等待状态切换到就绪状态（如：I/O完成）</li>
<li>当一个进程终止时<br>抢占调度对访问共享数据是有代价（如加锁）的，有可能产生错误，需要新的机制（如，同步）来协调对共享数据的访问。<br>抢占对于操作系统内核的设计也有影响。在处理系统调用时，内核可能忙于进程活动。这些活动可能涉及要改变重要内核数据(如I/O队列)。</li>
</ul>
<h4 id="分派程序"><a href="#分派程序" class="headerlink" title="分派程序"></a>分派程序</h4><p>分派程序（dispatch）是一个模块，用来将CPU的控制交给由短期调度程序选择的进程。<br>其功能包括：</p>
<ul>
<li>切换上下文</li>
<li>切换到用户模式</li>
<li>跳转到用户程序的合适位置，以重新启动程序。<br>分派程序停止一个进程而启动另一个所花的时间成为分派延迟。</li>
</ul>
<h3 id="调度准则"><a href="#调度准则" class="headerlink" title="调度准则"></a>调度准则</h3><ul>
<li>CPU使用率 : 需要使CPU尽可能忙</li>
<li>吞吐量 : 指一个时间单元内所完成进程的数量</li>
<li>周转时间 :从进程提交到进程完成的时间段称为周转时间，周转时间是所有时间段之和，包括等待进入内存、在就绪队列中等待、在CPU上执行和I/O执行</li>
<li>等待时间 : 在就绪队列中等待所花费时间之和</li>
<li>响应时间 : 从提交请求到产生第一响应的时间</li>
</ul>
<h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul>
<li>先来先服务(FCFS)</li>
<li>最短作业优先(SJF)</li>
<li>最短剩余时间优先调度</li>
<li>优先级调度</li>
<li>轮转法调度</li>
<li>多级队列调度</li>
<li>多级反馈地队列调度</li>
</ul>
<p>Linux 从整体上区分实时进程和普通进程，因为实时进程和普通进程度调度是不同的，它们两者之间，实时进程应该先于普通进程而运行，然后，对于同一类型的不同进程，采用不同的标准来选择进程。对普通进程的调度策略是动态优先调度，对于实时进程采用了两种调度策略，FIFO(先来先服务调度)和RR（时间片轮转调度）。</p>
<p>UNIX系统是单纯的分时系统，所以没有设置作业调度。UNIX系统的进程调度采用的算法是，多级反馈队列调度法。其核心思想是先从最高休先级就绪队列中取出排在队列最前面的进程，当进程执行完一个时间片仍未完成则剥夺它的执行，将它放入到相应的队列中，取出下一个就绪进程投入运行，对于同一个队列中的各个进程，按照时间片轮转法调度。多级反馈队列调度算法即能使高优先级的作业得到响应又能使短作业（进程）迅速完成。但是它还是存在某些方面的不足，当不断有新进程到来时，则长进程可能饥饿。</p>
<p>Windows 系统其调度方式比较复杂，它的处理器调度的调度单位是线程而不是进程，是基于优先级的抢占式多处理器调度，依据优先级和分配时间片来调度。而且Windows 2000/XP在单处理器系统和多处理器系统中的线程调度是不同的线程调度机制，Windows操作系统的调度系统总是运行优先级最高的就绪线程。在同一优先级的各线程按时间片轮转算法进行调度。如果一个高优先级的线程进入就绪状态，当前运行的线程可能在用完它的时间片之前就被抢占处理机。</p>
<h2 id="第六章-进程同步"><a href="#第六章-进程同步" class="headerlink" title="第六章 进程同步"></a>第六章 进程同步</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关，称之为竞争条件（race condition）</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区问题满足三项要求</p>
<ul>
<li>互斥</li>
<li>前进</li>
<li>有限等待</li>
</ul>
<p>一个操作系统，在某个时刻，可同时存在有多个处于内核模式的活动进程，因此实现操作系统的内核代码，会存在竞争条件。内核开发人员有必要确保其操作系统不会产生竞争条件。<br>有两种方法用于处理操作系统内的临界区问题：</p>
<p><strong>抢占内核（preemptive kernel）与非抢占内核（nonpreemptive kernel）：</strong><br>抢占内核允许处于内核模式的进程被抢占。<br>非抢占内核不允许内核模式的进程被抢占。</p>
<h3 id="peterson-算法"><a href="#peterson-算法" class="headerlink" title="peterson 算法"></a>peterson 算法</h3><h3 id="硬件同步"><a href="#硬件同步" class="headerlink" title="硬件同步"></a>硬件同步</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="系统表"><a href="#系统表" class="headerlink" title="系统表"></a>系统表</h4><p>资源的申请与释放为系统调用。其他资源的申请与释放可以通过信号量的wait与signal操作或通过互斥锁的获取与释放来完成。因此对于进程和线程的每次使用，操作系统会检查以确保使用进程已经申请并获得了资源。</p>
<p>系统表记录了每个资源是否空闲或已被分配，分配给了哪个进程。如果进程正在申请的资源正在为其他进程所使用，那么该进程会增加到该资源的等待队列。</p>
<h3 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h3><ul>
<li>有限缓存-生产者消费问题</li>
<li>读者-写者问题</li>
<li>哲学家进餐</li>
</ul>
<h2 id="第七章-死锁"><a href="#第七章-死锁" class="headerlink" title="第七章 死锁"></a>第七章 死锁</h2><h3 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h3><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul>
<li>互斥</li>
<li>占有并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
<h3 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h3><ul>
<li>可使用协议以预防或避免死锁，确保系统不会进入死锁状态。</li>
<li>可允许系统进入死锁状态，然后检测它，并加以修复。</li>
<li>可忽略这个问题，认为死锁不可能在系统内发生。</li>
<li>*死锁预防（deadlock prevention）**是一组方法，以确保至少一个必要条件不成立。这些方法通过限制如何申请资源的方法来预防死锁。</li>
</ul>
<p><strong>死锁避免（deadlock avoidance）</strong>要求操作系统事先得到有关进程申请资源和使用资源的额外信息。有了这些额外信息，系统可以确定：对于一个申请，进程是否应等待。为了确定当前申请是允许还是延迟，系统必须考虑可用资源，已经分配给每个进程的资源，每个进程将来申请和释放的资源。</p>
<h3 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h3><blockquote>
<p>出现死锁有四个必要条件，只要保证至少一个条件不成立，就能预防死锁的发生。</p>
</blockquote>
<h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>对于非共享资源，必须要有互斥条件（如打印机）。另一方面，共享资源不要求互斥访问，因此不会涉及死锁（如只读文件）。<br>故通常不能通过否定互斥条件来预防死锁，有的资源本身就是非共享的。</p>
<h4 id="占有并等待"><a href="#占有并等待" class="headerlink" title="占有并等待"></a>占有并等待</h4><p>为了确保占有并等待条件不会在系统内出现，必须保证：当一个进程申请一个资源时，就不能占有其他资源。</p>
<ul>
<li>方法一：可以通过要求申请资源的系统调用在所有其使用的协议是每个进程在执行前申请并获得所有资源。他系统调用之前进行。</li>
<li>方法二：允许进程在没有资源时才可申请资源，一个进程可申请一些资源并使用它们，然而，在它申请更多其他资源之前，它必须释放其现已分配的所有资源。<br>这两种协议有两个主要缺点：</li>
<li>第一，资源利用率（resource utilization）可能比较低，因为很多资源可能已分配，但长时间没有被使用。</li>
<li>第二，可能发生饥饿。一个进程如需要多个常用资源，可能会永久等待，比如因为其所需要的资源中至少一个总是分配给其他的进程。</li>
</ul>
<h4 id="非抢占"><a href="#非抢占" class="headerlink" title="非抢占"></a>非抢占</h4><p>为确保这一条件不成立，可使用如下协议：<br>即可以抢占，如果一个进程占用资源并申请另一个不能立即分配的资源，那么其现已分配的资源都可被抢占，即这些资源被隐式地释放了。只有当进程获得其原有资源和所申请的新资源时，进程才可以重新执行。<br>或者说，如果一个进程申请一些资源，首先检查是否可用，如果可用就分配它们，如果不可用，那么检查这些资源是否已分配给其他等待额外资源的进程。如果是就抢占这些资源，并分配给申请进程。如果资源不可用且也不可被其他等待进程占有，那么申请进程必须等待。当一个进程处于等待时，如果其他进程申请其拥有的资源，那么该进程部分资源可以被抢占。一个进程要重新执行，他必须分配到其所申请的资源，并恢复其在等待时被抢占的资源。<br>这个协议通常用于状态可以保存和恢复的资源，如CPU寄存器和内存，一般不适用其他资源，如打印机和磁带驱动器。</p>
<h4 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h4><p>一个确保此条件不成立的方法是：对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源。<br>每个进程只按照递增顺序申请资源，即一个进程开始可以申请任意数量的资源类型为Ｒｉ的实例。之后，当且仅当Ｆ（Rj）&gt;Ｆ（Ri）时，该进程可以申请资源Rj的实例。如果需要同一资源类型的多个实例，那么对它们必须一起申请。<br>例如，对于以上给定函数，一个进程如果同时需要打印机和磁带驱动器，那么就必须先申请磁带驱动器，再申请打印机。换句话说，要求当一个进程申请资源类型Rj时，必须先释放所有Ri[Ｆ（Ri）&gt;Ｆ（Rj）]</p>
<h3 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h3><p><strong>避免死锁的另外一种方法是获得以后如何申请资源的附加信息。</strong><br>不同的算法所要求的信息量和信息的类型上有所不同，最为简单和最为常用的模型要求每个进程说明可能需要的每种资源类型实例的最大需求。根据每个进程可能申请的每种资源类型实例的最大需求的事先信息，可以构造一个算法以确保系统绝不会进入死锁状态。这种算法定义了死锁避免（deadlock-avoidance）方法。<br>死锁避免算法动态地检测资源分配状态以确保循环等待条件不可能成立。资源分配状态是由可用资源和已分配资源，以及进程最大需求所决定的</p>
<h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><p>如果系统能按某个顺序为每个进程分配资源（不超过其最大值）并能避免死锁，那么系统状态就是安全的。即如果存在一个安全序列，那么系统处于安全状态。如果没有这样的顺序存在，那么系统处于不安全状态。<br>进程顺序{P1,P2,…,Pn}，如果对于每个Pi，Pi仍然可以申请的资源数小于当前可用资源加上所有进程Pj（其中j小于i）所占用资源，那么这一顺序称为安全序列。<br>在这种情况下，进程Pi所需要的资源即使不能立即使用，那么Pi等待直到所有Pj释放其资源，当它们完成时，Pi可得到其所需要的所有资源，完成其给定任务。<br>安全状态不是死锁状态，相反，死锁状态是不安全状态。然而，不是所有不安全状态都能够导致死锁状态。<br>只要状态为安全，操作系统就能避免不安全（和死锁）状态。在不安全情况下，操作系统不能阻止进程以会导致死锁的方式申请资源。进程行为控制了不安全状态。</p>
<h4 id="资源分配图算法"><a href="#资源分配图算法" class="headerlink" title="资源分配图算法"></a>资源分配图算法</h4><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>当新进程进入系统时，它必须说明其可能需要的各种类型资源实例的最大数量，这一数量不能超过当前系统资源的总和。当用户申请一组资源时，系统必须确定这些资源的分配是否仍会使系统出于安全状态，如果是，就分配资源；否则，进程必须等待直到某个其他进程释放足够资源为止。</p>
<h3 id="死锁恢复"><a href="#死锁恢复" class="headerlink" title="死锁恢复"></a>死锁恢复</h3><p>一种措施是通知操作员死锁已发生，以便操作人员人工处理死锁。<br>另一种措施是让系统从死锁状态中自动恢复过来。</p>
<p>打破死锁有两种方法：</p>
<ul>
<li>终止或多个进程以打破循环等待。</li>
<li>从一个或多个死锁进程那里抢占一个或多个资源。</li>
</ul>
<p>进程终止：</p>
<ul>
<li>终止所有死锁进程，这种方式虽然终止了死锁循环，代价太大。</li>
<li>一次只终止一个进程直到取消死锁循环为止，这种方法的开销会很大，因为每次终止一个进程，就需要调用死锁检测算法以确定进程是否仍处于死锁。</li>
</ul>
<p>资源抢占：<br>这里有三个问题需要处理：</p>
<ul>
<li>选择一个牺牲品：抢占哪些资源和哪个进程？必须确定抢占顺序以使代价最小化。 </li>
<li>回滚：如果从一个进程那里抢占一个资源，那么应对该进程做些什么安排？必须将这个进程回滚到某个安全状态，以便以后重启进程。<br>最简单的方法是完全回滚：终止进程并重新执行。更为有效的方法是将进程回滚到足够打破死锁。另一方面，这种方法要求系统维护有关运行进程状态的更多信息。</li>
<li>饥饿：如何确保不会发生饥饿？最为常用的方法是在代价因素中加上回滚次数。</li>
</ul>
<h2 id="第八章-内存管理"><a href="#第八章-内存管理" class="headerlink" title="第八章 内存管理"></a>第八章 内存管理</h2><h4 id="基本硬件"><a href="#基本硬件" class="headerlink" title="基本硬件"></a>基本硬件</h4><p>CPU所能直接访问的存储器只有内存和处理器内的寄存器<br>CPU内置寄存器通常可以在一个CPU时钟周期内完成访问<br>完成内存访问需要多个CPU时钟周期，由于没有数据以便完成正在执行的指令，CPU通常需要暂停（stall）。解决方法是在CPU与内存之间增加高速内存，称为高速缓存（cache）。</p>
<p>还要确保操作系统不会被用户进程所访问，确保用户进程不会被其他用户进程访问。<br>其中一种可能方案为：首先确保每个进程都有独立的内存空间，需要确定进程可访问合法地址的范围，并确保进程只能访问其合法地址。通过基地址寄存器（base register）和界限地址寄存器（limit register）可以实现这种保护。<br>基地址寄存器（base register）含有最小的物理内存地址，界限地址寄存器（limit register）决定了范围的大小</p>
<p>内存空间保护的实现，是通过CPU硬件对用户模式所产生的每个地址与寄存器的地址进程比较来完成的。如果访问了不该访问的地址，则会陷入到操作系统中，并作为致命错误处理。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_16-42-27.jpg"></p>
<p>只有操作系统可以通过特殊的特权指令来加载基地址寄存器和界限地址寄存器<br>由于特权指令只可在内核模式下执行，而只有操作系统在内核模式下执行，所以只有操作系统可以加载基地址寄存器和界限地址寄存器。这种方案允许操作系统修改两个寄存器的值，而不允许用户程序去修改他们。<br>操作系统在内核模式下，可以无限制地访问操作系统和用户内存。因此操作系统可以将用户程序装入用户内存，在出错时输出这些程序，访问并修改系统调用的参数等。</p>
<h4 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h4><p>通常，程序以二进制可执行文件的形式存储在磁盘上。为了执行，程序被调入内存并放入进程空间内。</p>
<p>许多系统允许用户进程放在物理地址的任意位置。这种组合方式会影响用户程序能够使用的地址空间。在绝大多数情况下，用户程序在执行前，会经过好几个步骤<br>在这些步骤中，地址可能有不同的表示形式，<strong>源程序</strong>中的地址通常是用<strong>符号</strong>表示，<strong>编译器通常将这些符号地址绑定（bind）在可重定位的地址</strong><br><strong>链接程序或加载程序再将这些可重定位的地址绑定成绝对地址</strong>每次绑定都是从<strong>一个地址空间到另一地址空间的映射</strong>。</p>
<p>通常，将指令与数据绑定到内存地址有以下几种情况：<br><strong>编译时</strong>（compile time）：如果编译时就知道进程将在内存中的驻留地址，那么就可以生成绝对代码（absolute code）。如果将来开始地址发生变化，那么就必须重新编译代码。<br><strong>加载时</strong>（load time）：当编译时不知道进程将驻留在内存的什么地方，那么编译器就必须生成可重定位代码（reloadable code）。绑定会延迟到加载时才进行。如果开始地址发生变化。只需要重新加载用户代码已引入改变值。<br><strong>执行时</strong>（execution time）：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定必须延迟到执行时才发生。绝大多数通用计算机操作系统采用这种方法。</p>
<h4 id="逻辑地址空间和物理地址空间"><a href="#逻辑地址空间和物理地址空间" class="headerlink" title="逻辑地址空间和物理地址空间"></a>逻辑地址空间和物理地址空间</h4><p>程序生成的地址通常称为逻辑地址，而内存单元所看到的地址（即加载到内存地址寄存器中的地址）通常称为物理地址。</p>
<p><strong>编译时绑定</strong>和<strong>加载时绑定</strong>生成相同的逻辑地址和物理地址。但是，<strong>执行时绑定</strong>会导致不同的逻辑地址和物理地址。对于这种情况，通常称逻辑地址为虚拟地址。<br>由程序所生成的所有逻辑地址称为<strong>逻辑地址空间</strong>，与这些逻辑地址相对应的物理地址的集合称为<strong>物理地址空间</strong>。</p>
<p>运行时从虚拟地址到物理地址的映射由被称为<strong>内存管理单元（memory-management unit，MMU）</strong>的硬件设备来完成。<br>有很多可选择的方法来完成这种映射，比如基地址寄存器方案的推广，基地址寄存器在这里称为重定位寄存器（relocation register），用户进程所生成的地址在送交内存之前，都加上重定位寄存器的值。</p>
<p>假如，基地址为14000，那么用户对地址346的访问将映射为地址14346。<br><img src="/2021/07/12/osnote-md/Xnip2021-06-03_16-55-15.jpg"><br>用户程序绝对不会看到真正的物理地址。只有当它作为物理地址时，它才进行相对于基地址寄存器的重定位。用户程序处理逻辑地址时，内存映射硬件将逻辑地址转变为物理地址。所引用的内存地址只有在引用时才最后定位。</p>
<p>逻辑地址空间映射到单独的一套物理地址空间，这一概念对内存的管理至关重要。</p>
<h4 id="动态加载（dynamic-loading）"><a href="#动态加载（dynamic-loading）" class="headerlink" title="动态加载（dynamic loading）"></a>动态加载（dynamic loading）</h4><p>一个进程的整个程序和数据如果都必须处于物理内存中，则进程的大小受物理内存大小的限制。为了获得更好的内存空间使用率，使用动态加载（dynamic loading），即一个子程序只有在调用时才被加载。</p>
<p>所有的子程序都以可重定位的形式保存在磁盘上。主程序装入内存并执行。当一个子程序需要调用另外一个子程序的时候，调用子程序首先检查另一个子程序是否已经被加载。如果没有，可重定位的链接程序将用来加载所需要的子程序，并更新程序的地址表以反应这一变化。接着控制传递给新加载的子程序。</p>
<p>动态加载的优点是不用子程序绝不会被加载，如果存在代码使用频率比较低，如错误处理，那么这种方法特别有用。</p>
<p>动态加载不需要操作系统提供特别的支持。利用这种方法来设计程序主要是用户的责任。</p>
<h4 id="动态链接（dynamically-linking）与共享库"><a href="#动态链接（dynamically-linking）与共享库" class="headerlink" title="动态链接（dynamically linking）与共享库"></a>动态链接（dynamically linking）与共享库</h4><p>有的操作系统只支持静态链接（static linking）此时系统语言库的处理与其他目标模块一样，由加载程序合并到二进制程序镜像中。</p>
<p><strong>动态链接</strong>的概念与<strong>动态加载</strong>相似。只是这里不是将加载延迟到运行时，而是将链接延迟到运行时。这一特点通常用于系统库，如语言子程序库，如果没有这个特点，系统上的所有程序都需要一份语言库的副本</p>
<p>如果有动态链接，二进制镜像中每个库程序的应用都有一个存根（stub）。存根是一小段代码，用以指出如何定位适当的内存驻留的库程序，或如果该程序不在内存中会指出如何安装入库。存根会用子程序地址来代替自己，并开始执行子程序。因此，下次再执程序代码时，就可以直接进行，而不会因动态链接产生任何开销。</p>
<p>动态连接也可用于库更新。一个库可以被新的版本所替代，且使用该库的所有程序会自动使用新的版本。没有动态链接，所有这些程序必须重新链接以便访问。</p>
<p>为了不使程序错用新的、不兼容版本的库，程序和库将包括版本信息。多个版本的库都可以装入内存，程序通过版本信息来确定使用哪个库副本。</p>
<p>因此，只有用新库编译的程序才会收到新库的不兼容变化影响。在新程序装入之前所链接的其他程序可以继续使用老库。这种系统也称为共享库。</p>
<p>与动态加载不同，动态链接通常需要操作系统帮助。因为内存中的进程是彼此保护的，那么只有操作系统才可以检查所需子程序是否在其他进程内存空间内，或是允许多个进程访问同一内存地址。</p>
<h4 id="连续内存分配（contiguous-memory-allocation）"><a href="#连续内存分配（contiguous-memory-allocation）" class="headerlink" title="连续内存分配（contiguous memory allocation）"></a>连续内存分配（contiguous memory allocation）</h4><p>内存应该尽可能有效地分配内存的各个部分，不浪费资源。</p>
<p>内存通常分为两个区域：一个用于驻留操作系统，一个用于用户进程。操作系统可以位于低内存或高内存，影响这一决定的主要因素是中断向量的位置。由于中断向量通常位于低内存，因此程序员通常将操作系统放到低内存。</p>
<p>采用连续内存分配（contiguous memory allocation）时，每个进程位于一个连续的内存区域。</p>
<h4 id="内存映射与保护"><a href="#内存映射与保护" class="headerlink" title="内存映射与保护"></a>内存映射与保护</h4><p>通过采用重定位寄存器和界限地址寄存器可以实现保护。</p>
<p>重定位寄存器含有最小的物理地址值；界限地址寄存器含有逻辑地址的范围值。</p>
<p>这样每个逻辑地址必须小于界限地址寄存器。MMU动态将逻辑地址加上重定位寄存器的值后影射成物理地址。映射后的物理地址再送交内存单元。<br><img src="/2021/07/12/osnote-md/Xnip2021-06-03_17-18-02.jpg"></p>
<p>当CPU调度器选择一个进程然后进行上下文切换工作时，调度程序会用正确的值来初始化重定位寄存器和界限地址寄存器。CPU所产生的每一地址都需要与寄存器进程核对，所以可以保证操作系统和其他用户程序和数据不受该进程的影响。</p>
<p>重定位寄存器机制为允许操作系统动态改变提供了一个有效方法。如某驱动程序（或其他操作系统服务）不常使用便可以不必在内存中，这类代码称为暂时性操作系统代码，它们根据需要调入或调出，使用这种代码可以在程序执行时动态改变操作系统的大小。</p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p><strong>固定大小分区</strong>。最简单的内存分配方法之一是将内存分为多个固定大小的分区。每个分区只能容纳一个进程。那么多道程序的程度会受分区数限制。如果使用这种多分区方法，当一个分区空闲时，可以从输入队列中选择一个进程调入到空闲分区。当进程终止时，其分区可以被其他进程所使用。这种方法现在已<strong>不再使用</strong>。这种固定分区方案的推广（称为MVT），它主要用于批处理环境。也可用于纯分段内存管理的分时操作系统。</p>
<p><strong>可变大小分区</strong>。在可变分区方案中，操作系统有一个表，用于记录那些内存可用和哪些内存已被占用。一开始，所有内存都可用于用户进程，因此可以作为一大块可用内存，称为孔（hole），当新进程需要内存时，为该进程查找足够大的孔，如果找到，可以从该孔进程分配所需的内存，孔内未分配的内存可用于下次再用。</p>
<p>随着进程进入系统，它们将被加入输入队列中。操作系统根据调度算法来对进程的输入队列进行排序。内存不断地分配给进程，直到下一个进程的内存需求不能满足为止，如果没有足够大的孔来装入进程，操作系统可以等到有足够大的空间，或者往下扫描输入队列以确定是否其他内存需求较小的进程可以被满足。</p>
<p>通常，一组不同大小的孔分散在内存中。当新进程需要内存时，系统为进程查找足够大的孔。如果孔太大，那么就分成两块：一块分配给新进程，另一块还回到孔集合，当进程终止时，它将释放其内存，该内存将还给孔集合。如果孔与其他孔相邻，那么将这些孔合并为大孔。这时，系统可以检查是否有进程在等待内存空间，新合并的内存空间是否满足等待进程。</p>
<p>那么我们如何寻找孔呢</p>
<p><strong>首次适应</strong>（first-fit）：分配<strong>第一个足够大</strong>的孔，查找可以从头开始，也可以从上次首次适应结束时开始。一旦找到足够大的空闲孔，就可以停止。</p>
<p><strong>最佳适应</strong>（best-fit）：分配<strong>最小的足够大</strong>的孔。必须查找整个列表，除非列表按照大小排序。这种方法可以产生最小剩余孔。</p>
<p><strong>最差适应</strong>（worst-fit）：分配<strong>最大</strong>的孔，同样必须查找整个列表，除非列表按照大小排序。这种方法可以产生最大剩余孔。该孔可能比最佳适应方法产生的最小剩余孔更有用。</p>
<p>模拟结果显示：首次适应和最佳适应方法在执行时间和利用空间方面都好于最差适应方法。首次适应和最佳适应方法在利用空间方面难分伯仲，首次适应方法更快些。</p>
<h4 id="碎片（fragmentation）"><a href="#碎片（fragmentation）" class="headerlink" title="碎片（fragmentation）"></a>碎片（fragmentation）</h4><p>首次适应和最佳适应算法都有<strong>外部碎片</strong>问题（external fragmentation）。随着进程装入和移出内存，空闲内存空间被分割为小分段，当所有总的空用内存之和可以满足请求但并不连续，这就出现了外部碎片问题。最坏的情况下，每两个进程之间就有空闲块（或浪费）。</p>
<p>在首次适应和最佳适应之间的选择可能会影响碎片的量。另一个影响因素是从空闲块的哪端开始分配。不管使用哪种算法，外部碎片始终是个问题。</p>
<p>内存碎片可以是内部的，也可以是外部的。如果内存以固定大小的块为单元来分配，进程所分配的内存可能比所要的要大。这两个数字之差称为<strong>内部碎片</strong>（internal fragmentation）这部分内存在分区内，但又不能使用。</p>
<p>一种解决外部碎片问题的方法是<strong>紧缩</strong>（compaction），紧缩的目的是移动内存内容，以便所有空闲空间合并成一整块。但是紧缩并非总是可能的。如果重定位是静态的，并且在汇编时或装入时进行的，那么就不能紧缩。紧缩仅在重定位是动态的并在运行时可采用。如果地址被动态重定位，可以首先移动程序和数据，然后再跟据新基地址基地的值来改变址寄存器。如果采用紧缩，还要评估其开销，最简单的合并算法是简单地将所有进城移到内存的一端，而将所有的孔移到内存的另一端，以生成一个大的空闲块。这种方案开销较大。</p>
<p>另一种解决方法外部碎片问题的方法是<strong>允许物理地址为非连续</strong>的。这样只要有物理内存就可以为进程分配。这种方案有两种互补的实现技术：<strong>分页和分段</strong>。这两种技术也可以合并。</p>
<p><em><strong>分页产生内部碎片，分段产生外部碎片</strong></em></p>
<h4 id="分页（paging）"><a href="#分页（paging）" class="headerlink" title="分页（paging）"></a>分页（paging）</h4><p>分页（paging）内存管理方案允许进程的物理地址空间可以使非连续的。</p>
<p>传统上，分页支持一直是由硬件来处理的。最近的设计是通过将硬件和操作系统相配合来实现分页。</p>
<h4 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h4><p>实现分页的基本方法设计将物理内存分为固定大小的块，称为帧（frame）；而将逻辑内存也分为同样大小的块，称为页（page）。当需要执行进程时，其page从备份存储中调入到可用的内存frame中。外围存储也分为固定大小的块，其大小与帧相同。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_17-36-12.jpg"></p>
<p>由CPU生成个每个地址分为两个部分：<strong>页号</strong>（p）和<strong>页位移</strong>（d）。<strong>页号作为页表的索引，页表包含每页所在物理内存的基地址，这些基地址与页偏移的组合形成物理地址，就可送交物理单元。</strong></p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_18-02-05.jpg"></p>
<p>页大小（与帧大小一样）是由硬件来决定的。通常为2的幂。选择页的大小为2的幂可以方便的将逻辑地址转换为页号和页偏移。如果逻辑地址空间为2m，且页大小为2n单元，那么逻辑地址的高m−n位表示页号（页表的索引），而低n位表示页偏移。每页大小从512B到16MB不等。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_18-03-27.jpg"></p>
<p><strong>设页大小为a，根据页号p得到基地址f，页偏移为d，则物理地址为f∗a+d</strong></p>
<p>分页是一种动态重定位。每个逻辑地址有分页硬件绑定为一定的物理地址。采用分页类似于使用一组基（重定位）地址寄存器，每个基地址对应这一个内存帧。</p>
<p>采用分页技术<strong>不会产生外部碎片</strong>：每个帧都可以分配给需要它的进程。不过分页<strong>有内部碎片</strong>。</p>
<p>每个页表的条目通常为4B，不过这是可变的，一个32位的条目可以指向232个物理帧的任何一个，如果帧为4KB，那么具有4B条目的系统可以访问244B大小。</p>
<p>当系统进程需要执行时，它将检查该进程的大小（按页计算）。进程的每页都需要一帧。因此，如果进程需要n页，那么至少应有n个帧。如果有那么就分配给新进程。进程的第一页装入一个已分配的帧，帧号放入进程的页表中。下一页分配给另一帧，其帧号也放入进程的页表中。</p>
<p>分页的一个重要特点是用户视角的内存和实际的物理内存的分离。用户程序将内存作为一整块来处理，而且它只包括这一个进程。事实上，一个用户程序与其他程序一起，分布在物理内存上。</p>
<p>用户视角的内存和实际的物理内存的差异是通过地址转换硬件协调的。逻辑地址转换为物理地址，这种映射是用户所不知道的，但是受操作系统所控制。注意用户进程根据定义是不能访问非它所占用的内存的。它无法访问其页表所规定之外的内存，页表只包括进程所拥有的那些页。</p>
<p>由于操作系统管理物理内存，它必须知道物理内存的分配细节：哪些帧已占用，哪些帧可用，总共有多少帧等。这些信息通常保存在帧表中。在帧表（frame table）中，每个条目对应一个帧，以表示该帧是空闲还是已占用，如果被占用，是被哪个进程的哪个页所占用。</p>
<p>另外，操作系统必须意识到用户进程是在用户空间内执行，且所有逻辑地址必须映射到物理地址。如果用户执行一个系统调用（如进行I/O），并提供地址作为参数，那么这个地址必须映射成物理地址。操作系统为每个进程维护一个页表副本，就如同它需要维护指令计数器和寄存器的内容一样。当操作系统必须手工将逻辑地址映射成物理地址时，这个副本可用来将逻辑地址转换为物理地址。当一个进程可分配到CPU时，CPU调度程序可以根据该副本来定义硬件页表。因此，分页增加了切换时间。</p>
<h4 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h4><p>每个操作系统都有自己的方法来保存页表。绝大多数都为每个进程分配一个页表。页表的指针与其他寄存器的值（如指令计数器）一起存入进程控制块。当调度程序需要启动一个程序时，它必须首先装入用户寄存器，并根据所保存的用户页表来定义正确的硬件页表值。</p>
<p>页表的硬件实现有很多方法。最为简单的是将页表作为一组专用寄存器（register）来实现。这些寄存器应用高速逻辑电路来构造，以便有效的进行分页地址的转换。由于对内存的每次访问都要经过分页表，因此效率很重要。CPU装入或修改页表寄存器的指令是特权级的，因此只有操作系统才可以修改内存映射图。</p>
<p>如果页表比较小（例如256个条目），页表使用寄存器还是比较合理的。但是，绝大多数当代计算机都允许页表非常大（如100万个条目）。对于这些机器，采用快速寄存器来实现页表就不可行了，因而需要将页表放在内存中，并将<strong>页表基寄存器（page-table base register，PTBR）</strong>指向页表。改变页表，只需要改变这一寄存器就可以了，这也大大降低了切换时间。</p>
<p>采用这种方法的问题是访问用户内存位置需要一些时间。如果要访问位置i，那么必须先用PTBR中的值再加上页号i的偏移，来查找页表。这一任务需要内存访问，根据所得的帧号，再加上页偏移，就得到了真实的物理地址，接着访问内存中所需的位置。采用这种方法，访问一个字节需要两次内存访问（一次用于页表条目，一次用于字节），这样内存访问的速度就减半，在绝大多数情况下这种延迟是无法忍受的。</p>
<p>对这一问题的标准解决方案是采用小但专用快速的硬件缓冲，这种缓冲称为<strong>转换表缓冲区（translation look-aside buffer，TLB）</strong>。TLB是关联的快速内存。TLB条目由两部分组成：键（标签）和值。当关联内存根据给定值查找时，它会同时与所有键进行比较。如果找到条目，那么就得到相应的值域。这种查找方式比较快，不过硬件也比较昂贵，通常，TLB中的条目数并不多，通常在64~1024之间。</p>
<p>TLB与页表一起按如下方式使用：TLB只包括页表中的一小部分条目。当CPU产生逻辑地址后，其页号提交给TLB。如果页码不在TLB中（称为TLB失效），那么就需要访问页表。将页号和帧号增加到TLB中。如果TLB中的条目已满，那么操作系统会选择一个来替换。替换策略有很多，从最近最少使用替换（LRU）到随机替换等。另外，有的TLB允许有些条目固定下来。通常内核代码的条目是固定下来的。</p>
<p>有的TLB在每个TLB条目中还保存地址空间标识码（address-space identifier，ASID）。ASID可用来唯一标识进程，并为进程提供地址空间保护。当TLB试图解析虚拟页号时，它确保当前运行进程的ASID与虚拟页相关的ASID相匹配。如果不匹配，那么就作为TLB失效。除了提供地址空间保护外，ASID允许TLB同时包含多个进程的条目。如果TLB不支持独立的ASID，每次选择一个页表时（例如，上下文切换时），TLB就必须被冲刷（flushed）或删除，以确保下一个进程不会使用错误的地址转换。<br><img src="/2021/07/12/osnote-md/Xnip2021-06-03_18-21-13.jpg"></p>
<p>页号在TLB中被查找到的百分比称为命中率。</p>
<p>80%的命中率意味着有80%的时间可以在TLB中找到所需的页号。</p>
<h4 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h4><p>在分页环境下，内存保护是通过与每个帧相关联的保护为来实现的。通常，这些位保存在页表中。</p>
<p><strong>可以用一个位来定义一个页是可读写还是只读的</strong>。每次地址引用都要通过页表来查找正确的帧码，在计算物理地址的同时，可以检查保护位来验证。对只读页进行写操作会向操作系统产生硬件陷阱(trap)（或内存保护冲突）。</p>
<p>可以很容易的扩展这一方法以提供更细致的保护，可以创建硬件以提供只读、读写、只执行保护。或者，通过为每种访问情况提供独立保护位，实现这些访问的各种组合；非法访问会被操作系统捕捉到。</p>
<p>还有一个位通常与页表中的每一条目相关联：有效-无效位。有效，表示相关的页在进程的逻辑地址空间内，因此是合法的页；无效，表示相关的页不在进程的逻辑地址空间内。通过使用有效-无效位可以捕捉非法地址。操作系统通过对该位可以允许或不允许对某页的访问。</p>
<p>有些系统提供硬件如页表长度寄存器（page-table length register，PTLR）来表示页表的大小，该寄存器的值可用于检查每个逻辑地址以验证其是否位于进程的有效范围内，如果检测无法通过，会被操作系统捕获。</p>
<h4 id="共享页"><a href="#共享页" class="headerlink" title="共享页"></a>共享页</h4><p>分页的优点之一在于可以共享公共代码。</p>
<p>可重入代码是不能自我修改的代码，它从不会在执行期间改变。两个或多个进程可以在相同的时间执行相同的代码。每个进程都有它自己的寄存器副本和数据存储，以控制进程执行的数据。两个不同进程的数据也将不同。</p>
<p>共享代码的只读特点不能只通过正确代码来保证，需要操作系统来强制实现。</p>
<h4 id="分段（segmentation）"><a href="#分段（segmentation）" class="headerlink" title="分段（segmentation）"></a>分段（segmentation）</h4><p>之前讲了采用分页内存管理，但是他有一个不可避免的问题，就是用户视角的内存和实际物理内存的分离。</p>
<h4 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h4><p>用户通常愿意将内存看作是一组不同长度的段的集合，这些段之间并没有一定的顺序。</p>
<p>分段（segmentation）就是支持这种用户视角内存管理方法。逻辑地址空间由一组段组成的。每个段都有名称和长度。地址指定了段名称和段内偏移。因此用户通过两个量来指定地址：**段名称(segment-number)<strong>和</strong>偏移(offset)**。</p>
<p>注意这一方案与分页的对比。在分页中，用户只指定一个地址，该地址通过硬件分为页码和偏移（高x位为页码，低n-x为偏移，或者反之）。</p>
<p>但是段是编号的，是通过段号而不是段名来引用的。因此，逻辑地址由有序对组成：&lt;segment−number,offset&gt;</p>
<p>通常，在编译用户程序时，编译器会自动根据输入程序来构造段。</p>
<p>一个C编译器可能会创建如下段：</p>
<ul>
<li>代码</li>
<li>全局变量</li>
<li>堆（内存从堆上分配）</li>
<li>每个线程采用的栈</li>
<li>标准的C库函数</li>
</ul>
<p>在编译时链接的库可能分配为不同的段。加载程序时会装入所有这些段，并为他们分配段号。</p>
<h5 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h5><p>用户虽然现在能够通过二维地址来引用程序中的对象，但是实际物理地址内存仍然是一维序列字节。因此，必须定义一个实现方式，以便将二维的用户定义地址映射为一维物理地址。这个地址是通过段表（segment table）来实现的。段表的每个条目都有段基地址和段界限。段基地址包含该段在内存中的开始物理地址，而段界限指定该段的长度。</p>
<p>一个逻辑地址由两部分组成：段号s和段内的偏移d。段号用来做段表的索引，逻辑地址的偏移d用位于0和段界限之间。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_18-31-48.jpg"><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/beyond_2016/article/details/81358067">https://blog.csdn.net/beyond_2016/article/details/81358067</a></p>
<h5 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h5><p>关于段页式在实际中使用的真实流程<br><strong>逻辑地址&lt;段号，偏移&gt;  -&gt;  虚拟地址&lt;页号，偏移&gt;  -&gt;  物理地址&lt;物理页号，偏移&gt;</strong></p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p>之前所介绍的内存管理算法都是基于一个基本要执行指令必须在物理内存中，满足这一要求的第一种方法是整个进程放在内存中。动态载入能帮助减轻这一限制，但是它需要程序员特别小心地做一些额外的工作。<br>指令必须都在物理内存内的这一限制，似乎是必须和合理的，但也是不幸的，因为这使得程序的大小被限制在物理内存的大小内。事实上，研究实际程序会发现，许多情况下并不需要将整个程序放到内存中。即使在需要完整程序的时候，也并不是同时需要所有的程序。·<br>虚拟内存（virtual memory）将用户逻辑内存和物理内存分开。这在现有物理内存有限的情况下，为程序员提供了巨大的虚拟内存。<br>根据之前所述，物理地址可以按页幁来组织，且分配给进程的物理页帧也可能不是连续的。这就需要内存管理单元（MMU）将逻辑页映射到内存的物理页帧。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_18-35-55.jpg"></p>
<p>如上图显示，运行随着动态内存的分配，堆可向上生长。类似地，还允许随着子程序的不断调用，栈可以向下生长。堆与栈之间的巨大空白空间(或hole)为虚拟地址的一部分，只有在堆与栈生长的时候，才需要实际的物理页。包括空白的虚拟地址空间成为稀地址空间，采用稀地址空间的优点是：随着程序的执行，栈或者堆段的生长或需要载入动态链接库（或共享对象）时，这些空白可以填充。<br>除了将逻辑内存与物理内存分开，虚拟内存也允许文件和内存通过共享页而为两个或者多个进程所共享，这样带来了如下优点</p>
<p>&nbsp;&nbsp;&nbsp; 通过将共享对象映射到虚拟地址空间，系统库可为多个进程所共享。虽然每个进程都认为共享库是其虚拟地址空间的一部分，而共享库所用的物理内存的实际页是为所有进程所共享。通常，库是按制度方式来链接每个进程的空间的。<br>&nbsp;&nbsp;&nbsp; 类似的，虚拟内存允许进程共享内存。两个或者多个进程之间可以通过使用共享内存来相互通信。虚拟内存允许一个进程创建内存区域，以便与其他进程进行共享。共享该内存区域的进程认为它是其虚拟地址空间的一部分，而事实上这部分是共享的。<br>&nbsp;&nbsp;&nbsp; 虚拟内存可允许在用系统调用fork()创建进程期间共享页，从而加快进程的创建。</p>
<h4 id="按需调页"><a href="#按需调页" class="headerlink" title="按需调页"></a>按需调页</h4><p>一个执行程序从磁盘载入内存的时候有两种方法。</p>
<ol>
<li>选择在程序执行时，将整个程序载入到内存中。不过这种方法的问题是可能开始并不需要整个程序在内存中。如有的程序开始时带有一组用户可选的选项。载入整个程序，也就将所有选项的执行代码都载入到内存中，而不管这些选项是否使用。</li>
<li>另一种选择是在需要时才调入相应的页。这种技术称为按需调页(demand paging)，常为虚拟内存系统所采用。<br>按需调页系统看类似于使用交换的分页系统，进程驻留在第二级存储器上（通常为磁盘）。当需要执行进程时，将它换入内存。不过，不是讲整个进程换入内存，而是使用懒惰交换(lazy swapper)。懒惰交换只有在需要页时，才将它调入内存。交换程序(swapper)对整个进程进行操作，而调页程序(pager)只是对进程的单个页进行操作。因此， 在讨论有关按需调页时，需要使用调页程序而不是交换程序。</li>
</ol>
<h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>当换入进程时，调页程序推测在该进程再次换出之前使用到的哪些页，仅仅把需要的页调入内存。从而减少交换时间和所需的物理内存空间。</p>
<p>这种方案需要硬件支持区分哪些页在内存，哪些在磁盘。采用有效/无效位来表示。当页表中，一个条目的该位为有效时，表示该页合法且在内存中；反之，可能非法，也可能合法但不在内存中。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_18-43-06.jpg"></p>
<p>如果进程从不试图访问标记为无效的页，那么并没有什么影响，因此，如果推测正确且只调入所有真正需要的页，那么进程就可如同所有页都调入内存一样正常运行。</p>
<p>当进程试图访问这些尚未调入内存的页时，会引起页错误陷阱（page-fault trap）。这种情况的处理方式如下：</p>
<ol>
<li>检查进程的内部页表（通常与PCB一起保存）。以确定该引用是的合法还是非法的地址访问。</li>
<li>如果非法，则终止进程；如果引用有效但是尚未调入页面，则现在进行调入。</li>
<li>找到一个空闲帧（如，从空闲帧表中选取一个）。</li>
<li>调度一个磁盘操作，以便将所需页调入刚分配的帧</li>
<li>磁盘读操作完成后，修改进程的内部表和页表，表示该页已在内存中。</li>
<li>重新开始因陷阱而中断的指令。</li>
</ol>
<p>如果没有空闲帧时该如何处理呢？</p>
<p>页替换：在内存中找到一些不再使用的页，将它换出去。</p>
<p>支持按需调页的硬件与分页和交换的硬件一样：<br><strong>页表</strong>：该表通过有效-无效位或保护位的特定值<br><strong>次级存储器</strong>：该次级存储器用来保存不再内存中的页。次级存储器通常为快速磁盘。它通常成为交换设备，用于交换的这部分磁盘称为交换空间</p>
<h5 id="按需调页的性能"><a href="#按需调页的性能" class="headerlink" title="按需调页的性能"></a>按需调页的性能</h5><p>其中页错误时间有很多，主要是下面三种：</p>
<ol>
<li>处理页错误中断</li>
<li>读入页（页换入时间）</li>
<li>重新启动进程</li>
</ol>
<p>按需调页的例子</p>
<p>内存存取时间 =200 ns  平均页错误服务时间 =8 ms  EAT=(1−p)×200 ns+p×8000000<br>如果每次1000次访问中有1次页错误，则EAT=8.2ns。即，因按需调页而慢40倍，如果需要性能降低不超过10%，则需要p&lt;0.0000025</p>
<p>因此来看，对于按需调页，<strong>降低页错误率</strong>至关重要。</p>
<p>另外是对交换空间的处理的使用。磁盘IO到交换空间通常比到文件系统要快，因为交换空间是按大块进行分配，并不使用文件查找和间接分配方法。<strong>因此，在进程开始时将整个文件镜像复制到交换空间，并从空间交换执行按页调度，那么有可能获得更好的性能</strong>。</p>
<p>另一种选择是开始时从文件系统进行按需调页，但置换出来的页写入交换空间，而后的调页则从交换空间中读取。这种方法确保只有需要的页才从文件系统中调入，又可以保证一定的性能。</p>
<h4 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h4><p>**写时复制Copy-on-Write (COW)**运行父进程与子进程开始时共享同一页面，这些页面标记为写时复制页，即如果任何一个进程需要对页进行写操作，那就复制一份共享页拿出来用。</p>
<p>写时复制所需一个空闲缓冲池，系统通常用按需填零(zero-fill-on-demand)的技术分配这些页。按需填零在需要分配之前先填零，因此清除了以前的内容。</p>
<p>下面的两个过程提箱了进程1修改C前后的物理内存的情况。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-03_18-53-22.jpg"></p>
<h4 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h4><p><strong>操作系统为何要进行页面置换呢？这是由于操作系统给用户态的应用程序提供了一个虚拟的“大容量”内存空间，而实际的物理内存空间又没有那么大。所以操作系统就就“瞒着”应用程序，只把应用程序中“常用”的数据和代码放在物理内存中，而不常用的数据和代码放在了硬盘这样的存储介质上。如果应用程序访问的是“常用”的数据和代码，那么操作系统已经放置在内存中了，不会出现什么问题。但当应用程序访问它认为应该在内存中的的数据或代码时，如果这些数据或代码不在内存中，则根据上文的介绍，会产生缺页异常。这时，操作系统必须能够应对这种缺页异常，即尽快把应用程序当前需要的数据或代码放到内存中来，然后重新执行应用程序产生异常的访存指令。如果在把硬盘中对应的数据或代码调入内存前，操作系统发现物理内存已经没有空闲空间了，这时操作系统必须把它认为“不常用”的页换出到磁盘上去，以腾出内存空闲空间给应用程序所需的数据或代码。</strong></p>
<p>操作系统迟早会碰到没有内存空闲空间而必须要置换出内存中某个“不常用”的页的情况。如何判断内存中哪些是“常用”的页，哪些是“不常用”的页，把“常用”的页保持在内存中，在物理内存空闲空间不够的情况下，把“不常用”的页置换到硬盘上就是页面置换算法着重考虑的问题。容易理解，一个好的页面置换算法会导致缺页异常次数少，也就意味着访问硬盘的次数也少，从而使得应用程序执行的效率就高。</p>
<p>置换基本流程</p>
<ol>
<li>查找需要页在磁盘上的位置。</li>
<li>查找一空闲帧：</li>
<li>如果有空闲帧，那么就使用它</li>
<li>如果没有空闲帧，那么就是用页置换算法选择一个“牺牲”帧（victim frame）</li>
<li>将牺牲帧的内容放到磁盘上，改变页表和帧表。</li>
<li>将所需页读入（新）空闲帧，改变页表和帧表。</li>
<li>重启用户进程。</li>
</ol>
<p>如果没有帧空闲，那么需要采用两个页传输（一个换出，一个换入）。可以通过使用修改位或脏位以降低额外开销。每当页内的任何字或字节被写入时，硬件就会设置该页的修改位以表示该页已被修改。这样的话，磁盘上页的副本的内容没有必要重写。</p>
<p>页置换是按需调页的基础。为实现按需调页，必须解决两个主要问题：必须开发**帧分配算法(frame-allocation algorithm)<strong>和</strong>页置换算法(page-replacement algorithm)**。如果在内存中有多个进程，那么必须决定为每个进程各分配多少帧。而且，当需要页置换时，必须选择要置换的帧。</p>
<p>可以这样来评估一个算法：针对特定内存引用序列，运行某个置换算法，并计算出页错误的数量。内存的引用序列成为引用串(reference string)。</p>
<p>第一，对给定页大小（页大小通常由硬件或系统来决定），只需要考虑页码，而不需要完整的地址。<br>第二，如果有一个页p的引用，那么任何紧跟着对页p的引用绝不会产生页错误。页p在第一次引用时已在内存中，任何紧跟着的引用绝不会出错。</p>
<h5 id="FIFO页置换"><a href="#FIFO页置换" class="headerlink" title="FIFO页置换"></a>FIFO页置换</h5><p>该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。FIFO算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIFO算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使缺页异常次数增多。</p>
<h5 id="最优-Optimal-置换"><a href="#最优-Optimal-置换" class="headerlink" title="最优(Optimal)置换"></a>最优(Optimal)置换</h5><p>所选择的被淘汰页面，将是以后永不使用的或许是在最长的未来时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。但由于操作系统其实无法预知一个应用程序在执行过程中访问到的若干页中，哪一个页是未来最长时间内不再被访问的，因而该算法是无法实际实现，但可以此算法作为上限来评价其它的页面置换算法。</p>
<h5 id="LRU（Least-Recently-Used）页置换"><a href="#LRU（Least-Recently-Used）页置换" class="headerlink" title="LRU（Least Recently Used）页置换"></a>LRU（Least Recently Used）页置换</h5><p>FIFO置换算法性能之所以较差，是因为它所依据的条件是各个页调入内存的时间，而页调入的先后顺序并不能反映页是否“常用”的使用情况。</p>
<p>最近最久未使用（LRU）置换算法，是根据页调入内存后的使用情况进行决策页是否“常用”。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页予以淘汰。该算法赋予每个页一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t,，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</p>
<p>算法的实现：由于LRU算法淘汰的是上次使用距离t时刻最远的页，故需记录这个距离。</p>
<h5 id="近似LRU页置换"><a href="#近似LRU页置换" class="headerlink" title="近似LRU页置换"></a>近似LRU页置换</h5><p>很少有计算机系统能够提供足够的硬件来支持真正的LRU页置换，因此必须使用其他置换算法。然而，许多系统都通过应用为方式提供一定支持，页表内的每项都关联着一个引用位(reference bit)，每当引用一个页时，相应页表的引用位就会被引脚置位。如添加一个8bit的引用位（极端情况下只有一个引用位，即二次机会算法）。每个时钟都向右移位，引用的话高位为1，否则为0。</p>
<p>开始，操作系统会将所有引用位都清零。随着用户进程的执行，与引用页相关联的引用位被硬件置位。通过检查引用位，能确定那些用过而那些没用过。这种部分排序信息导致了许多近似LRU算法的页置换算法。</p>
<ul>
<li><p>附加引用位算法：可以为位于内存中的每个表中的页保留一个8bit的字节。操作系统把每个页的引用位转移到其8bit字节的高位，而将其他位右移，并抛弃最低位。如果将8bit字节作为无符号整数，那么具有最小值的页为LRU页，且可以被置换。</p>
</li>
<li><p>二次机会算法：二次机会置换的基本算法是FIFO置换算法。当要选择一个页时，检查其引用位。如果其值为0，那么就直接置换该页。如果引用位为1，那么就给该页第二次机会，并选择下一个FIFO页。当一个页获得第二次机会时，其引用位清零。且其到达时间设为当前时间。因此获得第二次机会的页，在所有其他页置换之前，是不会被置换的。另外，如果一个页经常使用以致于其引用位总是得到设置，那么它就不会被置换。一种实现二次机会算法的方法是采用循环队列。用一个指针表示下次要置换哪个页。当需要一个帧时，指针向前移动直到找到一个引用位为0的页。在向前移动时，它将清除引用位。</p>
</li>
<li><p>增强型二次机会算法: 通过将引用位和修改位作为一个有序对来考虑，能增强二次机会算法。有下面四种可能类型：</p>
<ol>
<li>(0,0)最近没有使用且也没有修改。—用于置换的最佳页</li>
<li>(0,1)最近没有使用但修改过。—不是很好，因为在置换之前需要将页写出到磁盘</li>
<li>(1,0)最近使用过但没有修改  —它有可能很快又要被使用</li>
<li>(1,1)最近使用过且修改过    —它有可能很快又要被使用，且置换之前需要将页写出到磁盘</li>
</ol>
</li>
</ul>
<p>当页需要置换时，每个页都属于这四种类型之一。置换在最低非空类型中所碰到的页，可能要多次搜索整个循环队列。</p>
<h5 id="页缓冲算法"><a href="#页缓冲算法" class="headerlink" title="页缓冲算法"></a>页缓冲算法</h5><p>系统通常保留一个空闲帧缓冲池。当出现页错误时，会像以前一样选择一个牺牲帧，在牺牲帧写出之前，所需要的页就从缓冲池中读到空闲内存。</p>
<h4 id="帧分配"><a href="#帧分配" class="headerlink" title="帧分配"></a>帧分配</h4><h5 id="帧的最少数量"><a href="#帧的最少数量" class="headerlink" title="帧的最少数量"></a>帧的最少数量</h5><p>如何在各个进程之间分配一定的空闲内存？<br>简单办法是将帧挂在空闲帧链表上，当发生页错误之时即进行分配。进程终止时帧再次放回空闲帧链表。<br>帧分配策略受到多方面限制。<br>例如， 分配数不能超过可用帧数，也必须分配至少最少数量。保证最少量的原因之一是性能。页错误增加会减慢进程的执行。并且，在指令完成前出现页错误，该指令必须重新执行。所以有足够的帧至关重要。<br>每个进程帧的最少数量由体系结构决定，而最大数量是由可用物理内存数量决定。</p>
<h5 id="分配算法"><a href="#分配算法" class="headerlink" title="分配算法"></a>分配算法</h5><ul>
<li>平均分配，每个进程一样多</li>
<li>按进程大小使用比例分</li>
<li>按进程优先级分</li>
<li>大小和优先级组合分</li>
</ul>
<h5 id="全局分配和局部分配"><a href="#全局分配和局部分配" class="headerlink" title="全局分配和局部分配"></a>全局分配和局部分配</h5><p>全局置换允许进程从所有帧集合中选择一个进行置换，而不管该帧是否已分配给其他进程，即它可以从其他进程抢夺帧，比如高优先级抢夺低优先级的帧；局部分配则要求每个进程只能从自己的分配帧中分配。</p>
<p>局部置换要求每个进程仅从其自己的分配帧中进行选择<br>全局置换通常有更好的吞吐量，且更为常用。一个问题是不能控制页错误率。因为局部置换不能使用其他进程的不常用的内存。</p>
<h4 id="系统颠簸"><a href="#系统颠簸" class="headerlink" title="系统颠簸"></a>系统颠簸</h4><p>如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸（thrashing），颠簸其实就是频繁的页调度行为。</p>
<h5 id="系统颠簸的原因"><a href="#系统颠簸的原因" class="headerlink" title="系统颠簸的原因"></a>系统颠簸的原因</h5><p>如果一个进程没有分配到足够的页，那么就会导致页置换不断的发生，这将导致：</p>
<p>低CPU利用率<br>低CPU利用率导致系统认为需要引入新进程，增加多道程序的程度。<br>进程分配到的帧会更少<br>死循环</p>
<h4 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h4><p>文件的内存映射（memory-mapping）允许一部分虚拟内存与文件逻辑相关联。这样的结果是能够通过虚拟内存技术来将文件IO作为普通内存来访问。利用虚拟内存技术将文件I/O作为普通内存访问的方法叫做文件的内存映射。</p>
<p>开始的文件访问按普通请求页面调度来进行，会产生页错误。这样，一页大小的部分文件从文件系统读入物理页，以后文件的读写就按照通常的内存访问来处理</p>
<p>对于映射到内存的文件进行读写操作可能不会及时的更新到磁盘的文件当中。更新文件的操作通常由两种方式：<br>一、通过定期检查内存映射页是否改变来判断是否应该写磁盘<br>二、在关闭文件的时候将内存映射页写回磁盘，并从进程的虚拟内存中删除。</p>
<h4 id="内核内存的分配"><a href="#内核内存的分配" class="headerlink" title="内核内存的分配"></a>内核内存的分配</h4><p>当用户态进程需要额外内存时，可以从内核所维护的空闲页帧链表中获取页。但是，内核内存的分配通常是从空闲内存池中获取的。</p>
<p>内核内存的分配与普通用户（从进程空闲链表中获取）不同：</p>
<p>&nbsp;&nbsp;&nbsp; 内核分配内存时，有时需要的空间不到一页。因此，需要谨慎的分配内存，减少浪费。<br>&nbsp;&nbsp;&nbsp; 有些硬件需要直接和物理内存交互，因此需要分配连续的物理页</p>
<ul>
<li>buddy 系统</li>
<li>slab 分配</li>
</ul>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统和两个不同部分组成：一组文件和目录结构。<br><img src="/2021/07/12/osnote-md/Xnip2021-06-04_13-16-58.jpg"></p>
<h4 id="文件概念"><a href="#文件概念" class="headerlink" title="文件概念"></a>文件概念</h4><p>文件是记录在外存上得相关信息的具有名称的集合，具有连续的逻辑地址空间。通常，文件表示数据和程序。</p>
<p>数据文件可以包括，数字、字符、字符串或二进制。文件可以是自由形式，如文本文件，也可以具有严格的格式。</p>
<p>文件必须具有可以长期信息存储的性质、必须能够保存大容量数据、在进程终止后信息能够保留下来、能够多进程并发访问文件中的信息。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-04_13-19-24.jpg"></p>
<h5 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h5><ul>
<li>名称：按人们易读的方式保存的信息</li>
<li>标识符：用户不可读，用于在文件系统内进行该文件的标识</li>
<li>类型：用于操作系统辨认并执行</li>
<li>位置：文件位于硬盘上的位置的指针</li>
<li>大小：大小</li>
<li>保护：控制谁可以读、写、执行</li>
<li>时间、日期和用户标识：创建，上次修改，上次访问时间等信息，用于保护，安全，使用跟踪。</li>
</ul>
<p>文件的属性信息保存在硬盘上的目录结构中.而目录结构也保存在外存上。</p>
<h5 id="文件的操作-File-Operations"><a href="#文件的操作-File-Operations" class="headerlink" title="文件的操作(File Operations)"></a>文件的操作(File Operations)</h5><ul>
<li>创建：包含到文件系统中找到空间和在目录中为文件创建一个条目</li>
<li>写：需要执行系统调用。另外需要搜索目录查找文件位置和为该文件维护一个写位置的指针并在发生写操作时不断更新指针位置</li>
<li>读：需要执行系统调用。过程同写，需要搜索过程和维护读指针的位置</li>
<li>重定位：设置文件位置指针为给定值。该操作不需要真正的IO操作，也叫做寻址（seek）</li>
<li>删除：搜索，释放相关空间，并删除相应条目。</li>
<li>截短文件（truncate）：将文件长度设置为0KB，并释放相关空间，但不改变其他属性（不删除条目）。如截短一个命名为a.txt的文本文件后，它的大小会变为0kb，但文件名和其他属性可能没有变化。<br>上述的操作都涉及到为给定的文件搜索其在目录中的相关位置，为了避免不断搜索，在首次使用文件时，和使用完毕文件时，还需要执行两个操作：</li>
<li>打开（open）：为系统调用。将执行搜索，并将相关文件的所有内容都移动到内存中，需要操作时，通过该表的索引指定文件，并直接在内存中进行操作，从而避免了重新搜索和IO操作。</li>
<li>关闭（close）：为系统调用。将文件的索引从信息表中删除，并将相关信息从内存写到外存。<br>&nbsp;&nbsp;&nbsp; 操作系统维护包含所有打开文件的信息表（open-file table），当需要文件操作时，通过该表的索引指定文件。</li>
</ul>
<p>对于打开的文件，能够得到如下的信息：</p>
<ul>
<li>文件指针：读和写操作的指针</li>
<li>文件打开计数器：一个文件可以被多个进程打开，文件打开计数器记录该操作，当计数器为0时，可以删除该文件条目。</li>
<li>文件磁盘位置：定位文件在磁盘的位置</li>
<li>访问权限：每个进程用一个访问模式访问文件。<br>系统调用create和delete的操作的是关闭文件而不是打开的文件</li>
</ul>
<h5 id="内部文件结构"><a href="#内部文件结构" class="headerlink" title="内部文件结构"></a>内部文件结构</h5><p>由于磁盘文件总是按块来分配的，所以文件的最后一块的部分空间通常会被浪费。按块分配所浪费的字节称为内部碎片，块越大，内部碎片也越大。</p>
<h4 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h4><h5 id="顺序访问"><a href="#顺序访问" class="headerlink" title="顺序访问"></a>顺序访问</h5><p>顺序访问就是打开文件后，一个字节一个字节的读，一个20Kb的文件，必须先读完前10Kb（即使不做任何操作），才能访问到第11Kb。</p>
<p>顺序访问是通过一个指针操作的，指针可以按顺序移动（有的系统允许向前或者向后跳过n个记录），也可以重新设置到开始位置（reset）</p>
<h5 id="直接访问"><a href="#直接访问" class="headerlink" title="直接访问"></a>直接访问</h5><p>直接访问也叫相对访问，其原理是基于磁盘的特性的，磁盘能够随时访问其任意位置。</p>
<p>支持直接访问的文件中，文件由固定长度的逻辑记录组成，通过这种逻辑记录（如每一个块的编号，记录等）能够做到访问文件的任意位置。</p>
<p>直接访问可以立即访问大量信息，所以极为有用</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>为了管理数据，需要合理的组织方式</p>
<p>为简单起见，可以将存储文件系统的一大块（手动）分配的空间称为卷，一个卷可以存放多个操作系统。</p>
<p>每个卷包含了系统上文件的信息，保存在设备目录或卷表中。  设备目录记录了卷上所有文件的信息</p>
<h5 id="单层目录结构"><a href="#单层目录结构" class="headerlink" title="单层目录结构"></a>单层目录结构</h5><p><img src="/2021/07/12/osnote-md/Xnip2021-06-04_13-28-02.jpg"><br>在一个目录下存在：</p>
<p>命名问题：文件位于同一个目录下，他们必须具有唯一名称。<br>分组问题</p>
<h5 id="双层目录结构"><a href="#双层目录结构" class="headerlink" title="双层目录结构"></a>双层目录结构</h5><p>对于双层结构目录的结构，每个用户都有自己的用户文件目录(user file directory,UFD)。</p>
<p>因此在每个UFD中所有的文件名称唯一即可，不同的用户可以有相同拥有文件名的问题。</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-04_13-28-57.jpg"></p>
<p>虽然双层结构目录解决了名称冲突问题，但是它仍有缺点。这种解耦股有效地对用户加以隔离。这种隔离在用户需要完全独立时是有点，但是在用户需要在某个任务上进行合作和访问其他文件时却是一个缺点。</p>
<p>为了访问指定的文件唯一，用户必须知道要访问文件的路径名（path name）。也没有解决分组问题</p>
<h5 id="树状目录结构"><a href="#树状目录结构" class="headerlink" title="树状目录结构"></a>树状目录结构</h5><p>树是最常用的目录结构。树有根目录，并且系统内的每一个文件都有唯一路径名。</p>
<p>当前目录：通常情况下，一个进程都有一个当前目录，包含了进程当前感兴趣的绝大多数文件。子进程的当前目录通常是创建子进程的父进程的当前目录。 用户可以使用系统调用重新定义当前目录</p>
<p>路径名：路径名有绝对路径和相对路径两种形式，绝对路径从根路径开始，相对路径从当前目录开始</p>
<p>采用树状目录结构的一个问题是：如何处理删除目录。如果目录为空，那么可以简单的删除条目，如果目录不为空，可以有两个选择：</p>
<p>&nbsp;&nbsp;&nbsp; 强制要求如果目录不为空就无法删除目录。如MS-DOS系统<br>&nbsp;&nbsp;&nbsp; 递归删除目录下的所有子目录和文件。如linux下的rm命令</p>
<p><img src="/2021/07/12/osnote-md/Xnip2021-06-04_13-30-51.jpg"><br>上图表示的是树状目录。树状结构禁止共享文件和目录，因为允许共享文件和目录后，树就变成了图。</p>
<p>无环图是树状目录结构的一个扩展，允许目录含有共享子目录和文件<br><img src="/2021/07/12/osnote-md/Xnip2021-06-04_13-31-58.jpg"></p>
<h3 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h3><h4 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h4><p>磁盘提供大量的外存空间来维持文件系统。磁盘的下述两个特点使得其成为存储多个文件的方便介质。</p>
<ul>
<li>可以原地重写；</li>
<li>可以直接访问磁盘上的任意一块信息。</li>
</ul>
<p>为了提供对磁盘的高效且便捷的访问，操作系统通过文件系统来轻松地存储、定位、提取数据。文件系统有两个设计问题。</p>
<ul>
<li>定义文件系统对用户的接口</li>
<li>创建数据结构和算法来将逻辑文件系统映射到物理外存设备上<br>另外，与内存管理的部分方式相同，磁盘同样是以块为单位进行转移的。每块为一个或多个扇区</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/07/09/computerNet-md/" rel="prev" title="计算机网络部分知识点">
      <i class="fa fa-chevron-left"></i> 计算机网络部分知识点
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/07/12/git/" rel="next" title="git">
      git <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%AF%BC%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">第一章 导论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">第二章 操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="nav-number">2.1.</span> <span class="nav-text">系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">系统调用类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E5%88%86%E7%B1%BB"><span class="nav-number">2.1.2.</span> <span class="nav-text">系统程序分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">分层方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8"><span class="nav-number">2.2.2.</span> <span class="nav-text">微内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97"><span class="nav-number">2.2.3.</span> <span class="nav-text">模块</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.</span> <span class="nav-text">第三章 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">进程概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.2.</span> <span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%EF%BC%88PCB%EF%BC%89"><span class="nav-number">3.1.3.</span> <span class="nav-text">进程控制块（PCB）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">3.2.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="nav-number">3.2.1.</span> <span class="nav-text">调度队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">调度程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-1"><span class="nav-number">3.3.</span> <span class="nav-text">进程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">3.3.1.</span> <span class="nav-text">进程创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="nav-number">3.3.2.</span> <span class="nav-text">进程终止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">3.4.</span> <span class="nav-text">进程间通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">第四章 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%98%E7%82%B9"><span class="nav-number">4.1.1.</span> <span class="nav-text">多线程优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">多线程模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98"><span class="nav-number">4.2.</span> <span class="nav-text">多线程问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#fork-exec"><span class="nav-number">4.2.1.</span> <span class="nav-text">fork() exec()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%96%E6%B6%88"><span class="nav-number">4.3.</span> <span class="nav-text">线程取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-number">4.4.</span> <span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB"><span class="nav-number">4.5.</span> <span class="nav-text">共享</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%B8%AD%E6%96%AD-%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">4.5.1.</span> <span class="nav-text">硬中断 软中断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">4.5.2.</span> <span class="nav-text">孤儿进程 僵尸进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7"><span class="nav-number">4.5.3.</span> <span class="nav-text">信号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLS-%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%AD%98%E5%82%A8-thread-local-storage"><span class="nav-number">4.5.4.</span> <span class="nav-text">TLS 线程局部存储 thread local storage</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-CPU%E8%B0%83%E5%BA%A6"><span class="nav-number">5.</span> <span class="nav-text">第五章 CPU调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="nav-number">5.0.1.</span> <span class="nav-text">抢占调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%B4%BE%E7%A8%8B%E5%BA%8F"><span class="nav-number">5.0.2.</span> <span class="nav-text">分派程序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="nav-number">5.1.</span> <span class="nav-text">调度准则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">6.</span> <span class="nav-text">第六章 进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">6.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="nav-number">6.2.</span> <span class="nav-text">临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#peterson-%E7%AE%97%E6%B3%95"><span class="nav-number">6.3.</span> <span class="nav-text">peterson 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="nav-number">6.4.</span> <span class="nav-text">硬件同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">6.5.</span> <span class="nav-text">信号量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E8%A1%A8"><span class="nav-number">6.5.1.</span> <span class="nav-text">系统表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.</span> <span class="nav-text">经典同步问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%AD%BB%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">第七章 死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%89%B9%E5%BE%81"><span class="nav-number">7.1.</span> <span class="nav-text">死锁特征</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.1.1.</span> <span class="nav-text">必要条件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">7.2.</span> <span class="nav-text">死锁处理方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%A2%84%E9%98%B2"><span class="nav-number">7.3.</span> <span class="nav-text">死锁预防</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%92%E6%96%A5"><span class="nav-number">7.3.1.</span> <span class="nav-text">互斥</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%A0%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85"><span class="nav-number">7.3.2.</span> <span class="nav-text">占有并等待</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0"><span class="nav-number">7.3.3.</span> <span class="nav-text">非抢占</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85"><span class="nav-number">7.3.4.</span> <span class="nav-text">循环等待</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D"><span class="nav-number">7.4.</span> <span class="nav-text">死锁避免</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81"><span class="nav-number">7.4.1.</span> <span class="nav-text">安全状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.2.</span> <span class="nav-text">资源分配图算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="nav-number">7.4.3.</span> <span class="nav-text">银行家算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E6%81%A2%E5%A4%8D"><span class="nav-number">7.5.</span> <span class="nav-text">死锁恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">8.</span> <span class="nav-text">第八章 内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%A1%AC%E4%BB%B6"><span class="nav-number">8.0.1.</span> <span class="nav-text">基本硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A"><span class="nav-number">8.0.2.</span> <span class="nav-text">地址绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="nav-number">8.0.3.</span> <span class="nav-text">逻辑地址空间和物理地址空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%EF%BC%88dynamic-loading%EF%BC%89"><span class="nav-number">8.0.4.</span> <span class="nav-text">动态加载（dynamic loading）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88dynamically-linking%EF%BC%89%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%BA%93"><span class="nav-number">8.0.5.</span> <span class="nav-text">动态链接（dynamically linking）与共享库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%88contiguous-memory-allocation%EF%BC%89"><span class="nav-number">8.0.6.</span> <span class="nav-text">连续内存分配（contiguous memory allocation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="nav-number">8.0.7.</span> <span class="nav-text">内存映射与保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="nav-number">8.0.8.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A2%8E%E7%89%87%EF%BC%88fragmentation%EF%BC%89"><span class="nav-number">8.0.9.</span> <span class="nav-text">碎片（fragmentation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%EF%BC%88paging%EF%BC%89"><span class="nav-number">8.0.10.</span> <span class="nav-text">分页（paging）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95"><span class="nav-number">8.0.11.</span> <span class="nav-text">基本方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81"><span class="nav-number">8.0.12.</span> <span class="nav-text">硬件支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E6%8A%A4"><span class="nav-number">8.0.13.</span> <span class="nav-text">保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B1%E4%BA%AB%E9%A1%B5"><span class="nav-number">8.0.14.</span> <span class="nav-text">共享页</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%EF%BC%88segmentation%EF%BC%89"><span class="nav-number">8.0.15.</span> <span class="nav-text">分段（segmentation）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95-1"><span class="nav-number">8.0.16.</span> <span class="nav-text">基本方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6"><span class="nav-number">8.0.16.1.</span> <span class="nav-text">硬件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="nav-number">8.0.16.2.</span> <span class="nav-text">段页式</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-number">9.</span> <span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%83%8C%E6%99%AF-1"><span class="nav-number">9.0.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5"><span class="nav-number">9.0.2.</span> <span class="nav-text">按需调页</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">9.0.2.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%89%E9%9C%80%E8%B0%83%E9%A1%B5%E7%9A%84%E6%80%A7%E8%83%BD"><span class="nav-number">9.0.2.2.</span> <span class="nav-text">按需调页的性能</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="nav-number">9.0.3.</span> <span class="nav-text">写时复制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.0.4.</span> <span class="nav-text">页面置换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FIFO%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.0.4.1.</span> <span class="nav-text">FIFO页置换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E4%BC%98-Optimal-%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.0.4.2.</span> <span class="nav-text">最优(Optimal)置换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LRU%EF%BC%88Least-Recently-Used%EF%BC%89%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.0.4.3.</span> <span class="nav-text">LRU（Least Recently Used）页置换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%91%E4%BC%BCLRU%E9%A1%B5%E7%BD%AE%E6%8D%A2"><span class="nav-number">9.0.4.4.</span> <span class="nav-text">近似LRU页置换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%B5%E7%BC%93%E5%86%B2%E7%AE%97%E6%B3%95"><span class="nav-number">9.0.4.5.</span> <span class="nav-text">页缓冲算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%A7%E5%88%86%E9%85%8D"><span class="nav-number">9.0.5.</span> <span class="nav-text">帧分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%A7%E7%9A%84%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F"><span class="nav-number">9.0.5.1.</span> <span class="nav-text">帧的最少数量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">9.0.5.2.</span> <span class="nav-text">分配算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%88%86%E9%85%8D%E5%92%8C%E5%B1%80%E9%83%A8%E5%88%86%E9%85%8D"><span class="nav-number">9.0.5.3.</span> <span class="nav-text">全局分配和局部分配</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8"><span class="nav-number">9.0.6.</span> <span class="nav-text">系统颠簸</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%A2%A0%E7%B0%B8%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">9.0.6.1.</span> <span class="nav-text">系统颠簸的原因</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="nav-number">9.0.7.</span> <span class="nav-text">内存映射文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">9.0.8.</span> <span class="nav-text">内核内存的分配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.</span> <span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%A6%82%E5%BF%B5"><span class="nav-number">10.0.1.</span> <span class="nav-text">文件概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7"><span class="nav-number">10.0.1.1.</span> <span class="nav-text">文件属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%93%8D%E4%BD%9C-File-Operations"><span class="nav-number">10.0.1.2.</span> <span class="nav-text">文件的操作(File Operations)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">10.0.1.3.</span> <span class="nav-text">内部文件结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="nav-number">10.0.2.</span> <span class="nav-text">访问方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%AE%BF%E9%97%AE"><span class="nav-number">10.0.2.1.</span> <span class="nav-text">顺序访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE"><span class="nav-number">10.0.2.2.</span> <span class="nav-text">直接访问</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">10.0.3.</span> <span class="nav-text">目录结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8D%95%E5%B1%82%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">10.0.3.1.</span> <span class="nav-text">单层目录结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E5%B1%82%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">10.0.3.2.</span> <span class="nav-text">双层目录结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%91%E7%8A%B6%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="nav-number">10.0.3.3.</span> <span class="nav-text">树状目录结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.1.</span> <span class="nav-text">文件系统实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="nav-number">10.1.1.</span> <span class="nav-text">文件系统结构</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="l1nkr"
      src="/images/ye.jpg">
  <p class="site-author-name" itemprop="name">l1nkr</p>
  <div class="site-description" itemprop="description">Work it harder. Make it better</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/l1nkr" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;l1nkr" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lingfeng9911@gmail.com" title="E-Mail → mailto:lingfeng9911@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">l1nkr</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
